# Разделы

1. Терминология
2. Как работает antlr4 и зачем он нужен;
3. Из чего состоит грамматика;
4. Значение символов в грамматике;
5. Как читать грамматику;
6. Как сгенерировать новую грамматику;
7. Зачем нужен Visitor;
8. Как работает parser.

# 1. Терминология

1. Грамматика - это правила, по которым ANTLR будет читать строку.
2. ANTLR - это парсер, который читает строку и разбивает ее на токены.
3. Токен - часть выражения. В таком выражении `1 + 2` - 3 токена: `1`, `+`, `2`.
4. Лексер - ...

# 2. Как работает antlr4 и зачем он нужен

На входе есть строка, содержащая какое-то выражение.
Нужно выполнить это выражение и вернуть новую строку.

1. `Яблоко стоит {50 - 10} руб.` - `Яблоко стоит 40 руб.`
2. `Яблоко стоит {50 + 10} руб.` - `Яблоко стоит 60 руб.`

Нам нужно разобрать эту строку и вытащить выражение в скобках `{50 - 10}`
через парсер (6 пункт). Далее отдаем эту строку в ANTLR и он должен ее разобрать.
У ANTLR есть грамматика, в которой указано, как разобрать эту строчку.
Сначала нужно эту грамматику написать или использовать готовую и после сгенерировать JS код,
на основе этой грамматики.

# 3. Из чего состоит грамматика

У грамматики есть свои правила, файл должен иметь расширение `<fileName>.g4`.
В самом файле первым правилом идет `grammar <fileName>;`.
Filename должен совпадать, иначе работать не будет.
Далее грамматика делится на правила лексера и парсера.
Правила лексера пишутся в `PascaleCase` (или `SCREAMING_SNAKE_CASE`), парсера - `camelCase`.

```antlrv4
grammar README;

// --- Правила лексера

PLUS : '+'  ;
MINUS : '-' ;

NUMBER : Integer+ (Dot Integer+)? ;

fragment Dot : '.' ;
fragment Integer : [0-9] ;

// --- Правила парсера

expression : NUMBER ( PLUS | MINUS ) NUMBER ;
```

В правилах лексера мы описываем, какие токены нужно искать.
Здесь мы описывает, что нужно искать токены `PLUS`, `MINUS`, `NUMBER`. При этом мы видим, что `NUMBER`
состоит из каких-то частей, а именно из фрагментов. Все, что описано в фрагменте не будет являться токеном.
То есть вот такая строка `10 + 5.55` будет разбита на токены: `10`, `+`, `5.55` - и к каждому токену
мы можем обратиться, чтобы что-то сделать с этой информацией.

Если бы мы описали `Dot` не через фрагмент, а примерно также, как и `PLUS`. Тогда предыдущая строка
была бы разбита на такие токены: `10`, `+`, `5`, `.`, `55`.
Вот тут мы уже можем поработать с токеном `.` как-то отдельно, например, заменить его на запятую. 
Но в примере выше это не нужно, поэтому `Dot` будет фрагментом.

---

В правилах парсера мы описывает как будет выглядеть выражение, которое мы передадим парсеру.
Мы говорим, что выражение (`expression`) будет иметь одну цифру слева и одну цифру справа.
А посередине знак - плюс или минус.

# 4. Значение символов в грамматике

* Символ `|` будет помечен в таблице как `VL`

| Выражение    | Значение                                                                                                                                |
|--------------|-----------------------------------------------------------------------------------------------------------------------------------------|
| :            | Присвоение                                                                                                                              |
| ;            | Завершение операции                                                                                                                     |
| `VL`         | Или                                                                                                                                     |
| +            | Операция встречается 1 и более раз                                                                                                      |
| *            | Операция встречается 0 и более раз                                                                                                      |
| ?            | Необязательная операция                                                                                                                 |
| .            | Все, что угодно                                                                                                                         |
| -> skip      | Игнорировать                                                                                                                            |
| # expression | Идентификатор, через который можно найти конкретное выражение                                                                           |
| ( )          | Обертка для выражений, например: <br>`T1 (T2 VL T3) T4`. <br>Т - токен.<br>Тут мы говорим, что между Т1 и Т4 будет, либо Т2, либо Т3.   |

# 5. Как читать грамматику

```antlrv4
grammar MyGrammar;

PLUS   : '+' ;
MINUS  : '-' ;
NUMBER : [0-9]+ ;
STRING
       : '"' (.)*? '"'
       | '\'' (.)*? '\'';

WhiteSpace : (' ' | '\n' | '\r' | '\n\r') -> channel(HIDDEN);

compilationUnit : expression EOF ;

expression
    : expression op = (PLUS | MINUS) expression   # addSubExpression
    | NUMBER                                      # numberExpression
    | STRING                                      # stringExpression
    ;
```

Разберем данную грамматику в качестве примера. Сначала мы указываем список токенов, которые будем искать:
`PLUS`, `MINUS`, `NUMBER` (любая цифра от 0 до 9, которая повторяется 1 и болеер раз), `STRING`.

Разберем STRING:
1. Строка состоит из кавычек, которые будут в начале и в конце.
   Двойные кавычки помечаем как `'"'`, одинарные - `'\''`. 
2. Между кавычек может быть все, что угодно (`.`), и это "все что угодно" повторяется 0 и более раз (`*`).
При этом необязательно, что там вообще что-то будет (`?`).
   
Токен `HIDDEN` - это ключевое слово, которое означает, что мы что-то игнорируем.
В данном случаем мы создаем токен `WhiteSpace`, в котором указываем, что хотим игнорировать пустую строку и переносы символов.
На этом правила лексера завершены, далее идут правила парсера.

Тут у нас 2 выражения, первое `compilationUnit`, которое состоит из `expression` и `EOF`.
EOF - еще одно зарезервированное слово, которое означает конец строки.

Выражение expression уже сложнее, первое, на что стоит обратить внимание, это строка `op = (PLUS | MINUS)`.
Тут мы создаем переменную `op`, в которую записываем токен (плюс или минус), чтобы в будущем мы смогли обратиться
к этой переменной и достать знак. Выглядееть это будет примерно так:

```typescript
function visitAddSubExpression(context) {
  const operation = context._op.text;
  
  switch (operation) {
    case '+': // code...
    case '-': // code...
  }
}
```

В коде, когда будем использовать переменную, к ее имени нужно будет добавлять симовол `_` (пример выше).
Просто потому, что когда мы генерируем ANTLR он создаст эту переменную с этим символом.

Продолжаем разбирать выражение:
```antlrv4
expression
    : expression op = (PLUS | MINUS) expression   # addSubExpression
    | NUMBER                                      # numberExpression
    | STRING                                      # stringExpression
    ;
```

Вот этой строкой `# addSubExpression` мы устанавливаем идентификатор для выражения слева.
По итогу, используя этот идентификатор, мы в коде сможем обратиться к этому выражению.

Если посмотреть на него, то видно, что оно может быть числом или строкой.
Но также выражение может быть ссылкой на самого себя `expression op = (PLUS | MINUS) expression`.
Это означает, что левая часть выражения (`expression`) может быть строкой (`stringExpression`),
числом (`numberExpression`) или точно таким же выражением (`addSubExpression`).
Правая часть выражения работает аналогично. Разберем такую строку:

`5 + 10 - 50`

1. Сначала строка будет разбита так: `5 + 10`, `-`, `50`.
   Тут левая часть - это `addSubExpression`, правая - `numberExpression`; 
2. После мы видим, что левая часть - это выражение, значит его тоже нужно разбить на части;
3. Разбиваем на части: `5`, `+`, `10`.
   Тут левая часть - это `numberExpression`, правая - `numberExpression`.

И на этом все, грамматику можно усложнять как угодно, например, добавив умножение или деление.
И будет она уже выглядеть вот так:

```antlrv4
grammar MyGrammar;

PLUS   : '+' ;
MINUS  : '-' ;
STAR : '*';
DIV : '/';
NUMBER : [0-9]+ ;
STRING
       : '"' (.)*? '"'
       | '\'' (.)*? '\'';

WhiteSpace : (' ' | '\n' | '\r' | '\n\r') -> channel(HIDDEN);

compilationUnit : expression EOF ;

expression
    : expression op = (STAR | DIV | MODULO) expression  # mulDivExpression
    | expression op = (PLUS | MINUS) expression         # addSubExpression
    | NUMBER                                            # numberExpression
    | STRING                                            # stringExpression
    ;
```

# 6. Как сгенерировать новую грамматику

Если грамматика написала, то из нее нужно сгенерировать JS код. Чтобы это сделать, необходимо установить
Java (https://www.java.com/ru/). А далее использовать библиотеки:
1. `antlr4-cli` - генерирует JavaScript код; 
2. `antlr4ts-cli` - генерирует TypeScript код.

Разберу 2 пункт. В консоли пишем:
`antlr4ts ./path/to/<grammar>.g4 -visitor -no-listener -Xexact-output-dir -o ./src/ANTLR`

1. `-visitor` - генирирует код с паттерном Visitor (пункт 7);
2. `-no-listener` - генерирует код без паттерна Listener, который идет по умолчанию. Он не нужен
потому что я буду пользоваться паттерном visitor;
3. `-o ./src/ANTLR` - сгенирировать код по указанному пути;
4. `-Xexact-output-dir` - доп. настройка для `-o`, указывающая, что путь будет строиться относительный.
Если мы запускаем команду из папки `С://my_projects/my_antlr/`, тогда путь будет строиться от папки `my_antlr`.
По итогу код будет лежать в `C://my_projects/my_antlr/src/ANTLR`.

# 7. Зачем нужен Visitor

Паттерн

# 8. Как работает parser